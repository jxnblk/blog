{"path":"blog/design-graph","slug":"design-graph","title":"The Design Graph","date":"2020-02-18T00:00:00.000Z","excerpt":"A constraint-based system for organizing styles in UI design","html":"<p>import Graph from '../../components/graph'</p>\n<p>Working on various websites and web apps for over a decade,\nI've gravitated around certain words and phrases to talk about design constraints in user interfaces.\nDespite the rich vocabulary for talking about visual design,\nit feels like there isn't a great way to accurately describe the interconnected nature of working with design constraints.\nTalking about <em>color palettes</em>, using <em>typographic scales</em>,\n<em>themes</em> to codify the <em>design language</em>,\nor the <em>component API</em> of a particular library has often felt a little too disjointed for what I think should be a tightly woven system.</p>\n<p>The term <em>design systems</em> used to somewhat fill this void, however it's taken on a much larger meaning over the past few years\nand includes the people, organizations, and processes (among many other things), in addition to the implementation details.\nSo, how can we talk about the implementation details of UI design in a more precise way?\nAnd, how can we build upon these concepts to push UI design to a higher level of abstraction?</p>\n<p>While working on tools that prioritize <a href=\"/blog/interoperability\">interoperability</a>, <a href=\"/blog/themeability\">themeability</a>, <a href=\"/blog/portability\">portability</a>, and the <a href=\"/blog/a-conceptual-look-at-theming\">concepts</a> of libraries like <a href=\"https://theme-ui.com\">Theme UI</a>,\nI've started thinking about a more holistic view that I call the <em>Design Graph</em>.</p>\n<h2>What is the Design Graph?</h2>\n<blockquote>\n<p>The Design Graph is a constraint-based system for organizing styles in UI design.</p>\n</blockquote>\n<p>The Design Graph isn't an actual implementation, but rather a conceptual model\nthat includes pairwise relationships between its parts, or <em>nodes</em> to borrow a term from graph theory.\n<a href=\"https://theme-ui.com\">Theme UI</a> is one implementation that attempts to adhere to this model,\nand it's a great example of how the Design Graph can become more than the sum of its parts.\nTheme UI's source code isn't particularly complex or large, and it's similar to a few other libraries out there.\nThe thing that really differentiates Theme UI is that it's meant to be built upon, hacked on, and iterated on to enable a higher level of\n<a href=\"/blog/interoperability\">interoperability</a> across libraries.\n<strong>If you only look at what Theme UI <em>does</em>, you'll easily miss what it can <em>enable.</em></strong></p>\n<p>If you use Theme UI to build Gatsby themes, a component library, or a website,\nthese things should all <em>just work</em> with other tools like <a href=\"https://blocks-ui.com\">Blocks UI</a>.\nIn the future, imagine if there are VS Code and Figma plugins, documentation generators, static analysis tools, and more\nthat follow the same Design Graph schema so that the component library you have today gets a whole lot better over time.\nI want this imaginary future.</p>\n<h2>What is this for?</h2>\n<p>Beyond a larger ecosystem effect,\nthe Design Graph is meant to help answer some practical questions when implementing design systems, such as:</p>\n<h3><em>What should we call this?</em></h3>\n<p>Naming things is hard.\nThe fewer things you need to name, the more time and energy you can spend solving more important problems for your product.\nWith a standard interface and naming conventions for storing raw values in your UI,\nmore and more tools and abstractions can be built on top of this lower-level framework.\nBy naming things in a consistent way, we get <em>interoperability</em> for free.</p>\n<h3><em>Where should we put this?</em></h3>\n<p>Although people love to organize things, we're really terrible at doing so in a way that makes sense to others.\nThe Design Graph doesn't try to completely solve this, but it provides guidance for where certain aspects of your UI design should live.\nFor example, raw color values belong in the <code>colors</code> <em>scale</em>, and variations of your button styles belong in the <code>buttons</code> <em>variants</em>.</p>\n<h3><em>How do we use this?</em></h3>\n<p>Creating sensible but flexible component APIs is hard.\nWhen building out a library of components, it's generally beneficial to reuse props APIs across multiple components whenever possible.\nThis helps maintain a <em>minimum API surface area</em> and allows for a <em>learn once, use anywhere</em> effect.\nWith Theme UI,\ncontextual component styles can be set with the <code>variant</code> prop, and can be augmented or overridden with the <code>sx</code> prop, which acts as a sort of escape hatch.</p>\n<h2>What does it look like?</h2>\n<p>I would consider this a work-in-progress, but from a high level, the Design Graph includes the following core <em>nodes</em>:</p>\n<ul>\n<li><strong>Scales</strong> are limited collections of raw values that map to specific style properties.\nFor example, values for <code>font-size</code> are stored in the <code>fontSizes</code> scale.</li>\n<li><strong>Components</strong> are elements that have styles constrained by <em>scales</em>.</li>\n<li><strong>Variants</strong> are partial styles that map to specific components.\nFor example, a button might have <em>primary</em> and <em>secondary</em> variants, or <em>large</em> and <em>small</em> variants.</li>\n<li><strong>Themes</strong> are collections of <em>scales</em> (and possibly <em>variants</em>) that encapsulate a particular visual design language.\nIdeally, themes follow a common interface (or schema) and can be swapped out in different implementations.</li>\n</ul>\n<p>These nodes are inherently interconnected and help form the larger graph.</p>\n<h2>Themes to Scales</h2>\n<p>A <em>theme</em> object is composed of multiple <em>scales</em>. These scales could include fonts, font sizes, colors, and more.</p>\n<p>&#x3C;Graph\ntitle='Illustration of theme and scale nodes'\nnodes={[\n[8, 12, 6, 'Theme'],\n[18, 4, , 'Fonts'],\n[28, 10, , 'Colors'],\n[23, 20, , 'Space'],\n]}\nedges={[\n[0, 1],\n[0, 2],\n[0, 3],\n]}\n/></p>\n<h2>Scales to Components</h2>\n<p>A <em>component's</em> styles use <em>scales</em>.</p>\n<p>&#x3C;Graph\ntitle='Illustration of scale and component nodes'\nnodes={[\n[26, 14, 6, 'Component'],\n[8, 4, , 'Fonts'],\n[4, 12, , 'Colors'],\n[10, 20, , 'Space'],\n]}\nedges={[\n[0, 1],\n[0, 2],\n[0, 3],\n]}\n/></p>\n<h2>Scales to Variants</h2>\n<p><em>Variants</em> also use <em>scales</em>.\nVariants are usually the parts of a component's styles that might change contextually or dynamically.</p>\n<p>&#x3C;Graph\ntitle='Illustration of scale and variant nodes'\nnodes={[\n[24, 5, 5, 'Variant'],\n[24, 18, 5, 'Variant'],\n[10, 4, , 'Fonts'],\n[4, 12, , 'Colors'],\n[10, 20, , 'Space'],\n]}\nedges={[\n[0, 2],\n[0, 3],\n[0, 4],\n[1, 2],\n[1, 3],\n[1, 4],\n]}\n/></p>\n<h2>Component to Variants</h2>\n<p>A <em>component</em> can use multiple <em>variants</em>. Some variants can also be shared across multiple components.\nFor example, you could share accessible color combinations with a badge component and an alert or message component.</p>\n<p>&#x3C;Graph\ntitle='Illustration of component and variant nodes'\nnodes={[\n[26, 14, 6, 'Button'],\n[8, 6, 4, 'Primary'],\n[4, 20, 4, 'Secondary'],\n]}\nedges={[\n[0, 1],\n[0, 2],\n]}\n/></p>\n<h2>Putting it all together</h2>\n<p>As an example to demonstrate how some of these pieces fit together, a <em>theme</em> with typographic <em>scales</em> can be used to create a <em>component</em> that accepts multiple <em>variants</em>.</p>\n<pre><code class=\"language-js\">// example theme with typographic scales\n{\n  fonts: {\n    body: 'Helvetica',\n    heading: 'Garamond',\n  },\n  fontWeights: {\n    body: 400,\n    heading: 700,\n    bold: 700,\n  },\n  lineHeights: {\n    body: 1.625,\n    heading: 1.25,\n  },\n  fontSizes: [ 12, 14, 16, 20, 24, 32, 48 ],\n}\n</code></pre>\n<p>These <em>scales</em> can be used to create <em>variants</em>.</p>\n<pre><code class=\"language-js\">// example variants\ntext: {\n  heading: {\n    fontFamily: 'heading',\n    fontWeight: 'heading',\n    lineHeight: 'heading',\n    fontSize: 5,\n  },\n  title: {\n    fontFamily: 'heading',\n    fontWeight: 'heading',\n    lineHeight: 'heading',\n    fontSize: 6,\n  },\n  lead: {\n    fontFamily: 'body',\n    fontWeight: 'body',\n    lineHeight: 'body',\n    fontSize: 3,\n  },\n  small: {\n    fontFamily: 'body',\n    fontWeight: 'body',\n    lineHeight: 'body',\n    fontSize: 0,\n  },\n}\n</code></pre>\n<p>Then these <em>variants</em> can be used in a <em>component</em>.</p>\n<pre><code class=\"language-jsx\">&#x3C;Text as='h1' variant='heading'>\n  Hello\n&#x3C;/Text>\n&#x3C;Text variant='lead'>\n  This component has variants.\n&#x3C;/Text>\n</code></pre>\n<h2>More than the sum of its parts</h2>\n<p>Beyond a single application or site, the Design Graph is the sort of thing that can exist at a larger level across an entire organization or across multiple organizations.\nIn a way, the more libraries and applications that adopt this concept, the larger the graph gets,\nand the more tooling we can share.\nImagine installing a component from npm, and it's already compatible with your design system.\nOr imagine reusing a core set of components with variants across multiple clients with drastically different visual designs.\nImagine all these components can be visually tweaked from your design tool using a plugin\nand the changes are reflected back in your text editor.\nIf you're interested in helping build and shape this vision, join us on <a href=\"https://github.com/system-ui/theme-ui\">GitHub</a> or let me know what you think on <a href=\"https://twitter.com/jxnblk\">Twitter</a>.</p>\n<p><em>Thanks to John Otander for related explorations in <a href=\"https://github.com/system-ui/designql\">DesignQL</a>, Jina Anne for all the work on design tokens, and Diana Mounter for infinite inspiration.</em></p>\n"}