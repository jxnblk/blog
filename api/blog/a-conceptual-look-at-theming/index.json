{"path":"blog/a-conceptual-look-at-theming","title":"A Conceptual Look at Theming","date":"2019-08-10T00:00:00.000Z","excerpt":"An exploration on the relationship between global and component-based styles and a mental model for styling applications.","html":"<p>The word <em>theme</em> can mean a lot of different things and invoke a lot of different interpretations,\nwhich can be both a blessing and a curse.\nIn user interface design, the term <em>theming</em> is used for various purposes, including end-user customization, white labels, customizable UI components, and color variations such as dark and light modes.\nHere, I'd like to step back and look at some of the foundational concepts that libraries like <a href=\"https://theme-ui.com\">Theme UI</a>, <a href=\"https://styled-system.com\">Styled System</a>, <a href=\"https://rebassjs.org\">Rebass</a>, and <a href=\"https://basscss.com\">Basscss</a> have been driven by.\nI've tried to codify some of these concepts in different implementations and APIs in various open source projects dating back to 2013,\nbut many of these projects are aimed at a similar problem space.\nThis isn't meant to be an exhaustive analysis of theming in general, but more of a framework for how to think about UI design and design systems,\nand how you can apply some of this thinking to your own work.</p>\n<h2>Spectrum</h2>\n<pre><code>Global &#x3C;--> Component\n</code></pre>\n<p>When it comes to styling, there is a dichotomy between styles that are global and styles that are scoped to individual components.\nGenerally speaking, CSS tends towards the former and libraries like <a href=\"https://styled-components.com\">Styled Components</a> tend towards the latter.\nWhen using any technology, how decoupled versus how scoped you choose to create your styles varies from application to application,\nand each approach has its merits.\nConsidering the spectrum spanning from global to component-based styles can be\na good yardstick for making decisions about styling responsibility when constructing a design system.</p>\n<h2>Stylesheets</h2>\n<p>In the pure ideal that is <a href=\"http://www.csszengarden.com/\">CSS Zen Garden</a>, styles are completely decoupled from components,\nallowing the components to remain the same while the styles are swapped out one-by-one.\nIn practice, this is virtually impossible to achieve in a real world application with tens, hundreds, or thousands of contributors,\nand in situations that have devolved into <em>append-only stylesheets</em>.\nThe global stylesheet can be thought of as a large object composed of many nested style objects that are intended for other components.\nCSS rulesets are mapped to components via CSS selectors,\nwhich is effectively a language-specific function\nthat takes stylesheets and full HTML element trees as inputs, and applies styles to element trees.</p>\n<p>With this sort of approach, <a href=\"https://en.wikipedia.org/wiki/Dead_code_elimination\">dead code elimination</a>, <a href=\"https://en.wikipedia.org/wiki/Tree_shaking\">tree shaking</a>, and dynamic <a href=\"https://webpack.js.org/guides/code-splitting/\">code splitting</a> of the styles is extremely difficult,\nbut styles are available <em>anywhere and everywhere</em> they <em>might</em> be needed.\nFor small sites and smaller teams, this approach can sometimes be the quickest and cheapest approach.</p>\n<h2>Components</h2>\n<p>With a component-based approach, the default is complete isolation of styles.\nThis gives you dead code elimination of styles for free.\nIt also lends itself well to tree shaking and dynamic code splitting,\nwhich can create huge performance improvements, especially in larger applications.\nThis also, inevitably, leads to duplication of styles.\nWhile libraries like Styled Components offer a theming context,\nthe tendency is to use that as a simple mode switch rather than a store for shared styles.</p>\n<h2>Scales</h2>\n<blockquote>\n<p><em>scale</em>: a graduated series of musical tones ascending or descending in order of pitch according to a specified scheme of their intervals</p>\n</blockquote>\n<p>Styled System leverages the theming context in libraries like this to provide sets of style values in the form of <em>scales</em> that create the larger <em>theme object</em>.\n<strong>These scales create design constraints for specific style properties that help teams realize a consistent visual design language throughout an application's user interface.</strong>\nThese scales become inputs to functional components.\nIn component-based UI development, the resulting interface is a function of data and/or state.\nWhen styling interfaces, the theme object can be thought of as a part of state,\nwhere each component's styles becomes a function of the theme object, component-based styles, and component props.</p>\n<h2>Responsibilities</h2>\n<p>With the abstraction provided by the theme object, different styling responsibilities can be put in different places.\nColor definitions, typographic styles, space scales, and other commonly used style values become the responsibility of the theme object.\nDynamic styles, such as responsive styles based on viewport width, become the responsibility of the component,\nwhich lends itself well to contextual style changes based on content.</p>\n<h2>Variants</h2>\n<p><em>Update: the variants API in Styled System has changed since first publishing this post.</em></p>\n<p>The division of responsibilities across the spectrum of global to component-based styles\ngets a little murky when considering the <a href=\"https://styled-system.com/variants\">variants API</a> in Styled System.\nComplete style objects can be stored in the global theme object and applied to components with a simple shorthand.\nFor example, a <code>Button</code> component can switch between stylistic variants by setting the <code>variant</code> prop, which pulls in values from the theme.</p>\n<pre><code class=\"language-jsx\">&#x3C;Button variant='primary'>Beep&#x3C;/Button>\n&#x3C;Button variant='secondary'>Boop&#x3C;/Button>\n</code></pre>\n<p>While this can be good for developer ergonomics, it flies in the face of tree-shakeability and code splitting.\nStyles that would have otherwise been scoped to the component's module are now globally available.\nFor commonly used styles like typography, this can make more sense, but it still blurs the lines of where this sort of responsibility should lie.</p>\n<h2>MDX Styles</h2>\n<p>In <a href=\"https://theme-ui.com\">Theme UI</a>, markdown and MDX content can be styled using a <a href=\"https://theme-ui.com/styling-mdx\"><code>theme.styles</code></a> object that uses base-level theme scales to style headings, paragraphs, lists, blockquotes, and other markdown elements.\nThis API too introduces a bit of ambiguity to the concept of theming, but it allows for near-complete typographic styles to be reused and shared across many different MDX documents.\nIn a way, the <code>theme.styles</code> object <em>is</em> a component in a more abstract and conceptual sense.</p>\n<h2>The Right Way</h2>\n<p>I'm often asked which way is <em>the right way</em> to handle things like this.\nThe short answer is, there are no wrong or right ways,\nbut I think considering the implications of storing stylistic values in different places\nacross the spectrum of global to component-based styles can be a useful framework\nfor defining the API of a design system.\nAll roads lead to Rome, so don't be afraid to explore new territory or wander off the beaten path from time to time.</p>\n<!-- Graph Theory -->\n"}