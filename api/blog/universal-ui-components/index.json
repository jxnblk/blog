{"path":"blog/universal-ui-components","title":"Universal UI Components","date":"2016-07-06T00:00:00.000Z","excerpt":"<p>For a while now, I’ve been interested in the idea of creating portable,\ninteroperable functional UI components that can work in any DOM rendering library,\nwhether it’s\n<a href=\"https://facebook.github.io/react/\">React</a>,\n<a href=\"https://preactjs.com\">Preact</a>,\n<a href=\"https://github.com/dominictarr/hyperscript\">hyperscript</a>,\n<a href=\"https://github.com/shama/bel\">bel</a>,\n<a href=\"https://github.com/maxogden/yo-yo\">yo-yo</a>,\nor some other library.</p>\n<p>The idea of functional UI components is a simple one: pass arguments into a function and it returns a representation of the DOM,\nusually with encapsulated styles and interactivity handled with callbacks to a global state, a la Redux.</p>\n","html":"<p>For a while now, I’ve been interested in the idea of creating portable,\ninteroperable functional UI components that can work in any DOM rendering library,\nwhether it’s\n<a href=\"https://facebook.github.io/react/\">React</a>,\n<a href=\"https://preactjs.com\">Preact</a>,\n<a href=\"https://github.com/dominictarr/hyperscript\">hyperscript</a>,\n<a href=\"https://github.com/shama/bel\">bel</a>,\n<a href=\"https://github.com/maxogden/yo-yo\">yo-yo</a>,\nor some other library.</p>\n<p>The idea of functional UI components is a simple one: pass arguments into a function and it returns a representation of the DOM,\nusually with encapsulated styles and interactivity handled with callbacks to a global state, a la Redux.</p>\n<!-- more -->\n<p>If you look at the currently available technology, there are predominantly three ways to create these components:</p>\n<ul>\n<li><a href=\"https://facebook.github.io/jsx/\"><strong>JSX</strong></a> (from React) - uses an XML-like syntax to call functions that return representations of DOM elements</li>\n<li><a href=\"https://github.com/dominictarr/hyperscript\"><strong>Hyperscript</strong></a> - similar to JSX, but uses standard JavaScript syntax and function calls</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals\"><strong>ES2015 tagged template literals</strong></a> - a new string type introduced to JavaScript</li>\n</ul>\n<p>Each has its own pros and cons. While JSX is mostly syntactic sugar, some prefer to use standard JavaScript syntax.\nOne big advantage JSX has is that it abstracts away the function used to create DOM elements.\nFor example, React uses <code>React.createElement</code> while Preact uses <code>Preact.h</code>.\nThe pragma used in JSX is configurable by the end user.\nHyperscript, although older than JSX, uses a similar function, but is written in standard JavaScript.\nTagged template literals are also standard JavaScript,\nbut require a little bit of extra code to change template literals into DOM elements.</p>\n<h2>The same, but different</h2>\n<p>Assuming we pick one of the above syntaxes,\nthere are relatively few differences among the implementations of components across libraries.\nFor example, here is a bare-bones Button component for several different libraries.\nFor brevity, styles have been left out of these examples.</p>\n<pre><code class=\"language-js\">// React using JSX\nimport React from 'react'\n\nconst Button = (props) => (\n  &#x3C;button {...props} />\n)\nexport default Button\n</code></pre>\n<pre><code class=\"language-js\">// Preact using JSX\nimport { h } from 'preact'\n\nconst Button = (props) => (\n  &#x3C;button {...props} />\n)\nexport default Button\n</code></pre>\n<pre><code class=\"language-js\">// Hyperscript\nimport h from 'hyperscript'\n\nconst Button = (props) => (\n  h('button', props)\n)\nexport default Button\n</code></pre>\n<pre><code class=\"language-js\">// yo-yo using tagged template literals\nimport yo from 'yo-yo'\n\nconst Button = ({ text, ...props }) => (\n  yo`&#x3C;button ${props}>${text}&#x3C;/button`\n)\nexport default Button\n</code></pre>\n<p>There are still quite a few differences in syntax between JSX, hyperscript, and tagged template literals.\nFor the sake of this post, I’ll focus on implementing these components in JSX.</p>\n<p>The first three examples are covered, but here’s what the hyperscript and yo-yo examples would look like in JSX.</p>\n<pre><code class=\"language-js\">// Hyperscript with JSX\nimport h from 'hyperscript'\n\nconst Button = (props) => (\n  &#x3C;button {...props} />\n)\nexport default Button\n</code></pre>\n<pre><code class=\"language-js\">// bel (yo-yo) with JSX\n// yo-yo uses the bel package to create elements\nimport { createElement } from 'bel'\n\nconst Button = (props) => (\n  &#x3C;button {...props} />\n)\nexport default Button\n</code></pre>\n<p>For each of the non-React versions, JSX needs to be configured to use the appropriate pragma.\nHyperscript and Preact both name their create element functions <code>h</code>.\nHere is an example <code>.babelrc</code> configuration.</p>\n<pre><code class=\"language-json\">{\n  \"presets\": [\n    \"es2015\",\n    \"stage-0\"\n  ],\n  \"plugins\": [\n    [\n      \"transform-react-jsx\",\n      { \"pragma\": \"h\" }\n    ]\n  ]\n}\n</code></pre>\n<p>Although the other libraries name their create element functions differently,\nthey can all be named <code>h</code> within the components for cross-library compatibility.</p>\n<pre><code class=\"language-js\">// React using JSX\nimport { createElement as h } from 'react'\n\nconst Button = (props) => (\n  &#x3C;button {...props} />\n)\nexport default Button\n</code></pre>\n<p>At this point, the only difference in these components across libraries is the <code>import</code> statement.\nUsing a module bundler like webpack, even this can be abstracted out of the component module.</p>\n<p>Using webpack’s ProvidePlugin, the create element function can be exposed to all modules.\nThis does involve having a variable in the global scope, but I think the trade-off might be worth it in some cases.</p>\n<pre><code class=\"language-js\">// Custom create-element module\nconst h = require('preact').h\nmodule.exports = h\n</code></pre>\n<pre><code class=\"language-js\">// Example webpack configuration for Preact\nconst path = require('path')\nconst webpack = require('webpack')\n\nmodule.exports = {\n  ...,\n  plugins: [\n    new webpack.ProvidePlugin([\n      h: path.resolve('./preact-create-element')\n    ])\n  ]\n}\n</code></pre>\n<p>To avoid variable collisions, the function could be named anything (e.g. <code>__h</code>) as long as the <code>.babelrc</code> pragma matches.</p>\n<p>In addition to the name of the create element function, there are some slight differences in the naming conventions\nfor HTML attributes (e.g. <code>htmlFor</code> and <code>className</code>) and handling child elements.\nTransforming these props could be handled in the custom function, but the implementation details have been left out of this post.</p>\n<p>With this configuration, the Button component can now be written like this:</p>\n<pre><code class=\"language-js\">const Button = (props) => (\n  &#x3C;button {...props} />\n)\nexport default Button\n</code></pre>\n<p>I’ve put up a rough demonstration of this concept, with the same two UI components being rendered to the DOM by\nReact, Preact, hyperscript, and bel here: <a href=\"http://jxnblk.com/universal-components\">Universal Components</a>.</p>\n<p>With a little bit of configuration, a whole library of UI components could be written in a manner that would allow\nthe DOM rendering library to be swapped out at some point in the future,\nwithout the need to use a tool like <a href=\"https://github.com/facebook/codemod\">Codemod</a>.\nThere’s probably even a way to wrap components in an open-source library like <a href=\"http://jxnblk.com/rebass\">Rebass</a>\nto make them compatible with more than one functional DOM rendering library as well.</p>\n"}