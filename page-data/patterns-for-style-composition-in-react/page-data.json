{"componentChunkName":"component---node-modules-jxnblk-gatsby-theme-mdx-blog-src-templates-post-js","path":"/patterns-for-style-composition-in-react/","webpackCompilationHash":"e17fc85b2ab38f68e9e9","result":{"data":{"mdx":{"id":"f5d2ef85-f8a1-5490-8d9b-b1ab9c6b5674","frontmatter":{"title":"Patterns for Style Composition in React","date":"August 13, 2016","draft":null},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Patterns for Style Composition in React\",\n  \"excerpt\": \"While React is extremely flexible in terms of how you can structure your application’s UI, I’ve found that a few patterns for style composition have helped me keep things organized and easy to work with.\",\n  \"date\": \"2016-08-13T00:00:00.000Z\",\n  \"tags\": [\"css\", \"css-in-js\", \"design systems\", \"style guides\", \"react\"],\n  \"related\": [{\n    \"name\": \"Pure UI by Guillermo Rauch\",\n    \"href\": \"http://rauchg.com/2015/pure-ui/\"\n  }, {\n    \"name\": \"CSS in JS by Christopher \\\"vjeux\\\" Chedeau\",\n    \"href\": \"https://speakerdeck.com/vjeux/react-css-in-js\"\n  }, {\n    \"name\": \"Presentational and Container Components by Dan Abramov\",\n    \"href\": \"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.68k59nncg\"\n  }, {\n    \"name\": \"Reflexbox\",\n    \"href\": \"http://jxnblk.com/reflexbox\"\n  }, {\n    \"name\": \"Rebass\",\n    \"href\": \"http://jxnblk.com/rebass\"\n  }, {\n    \"name\": \"Robox\",\n    \"href\": \"https://github.com/jxnblk/robox\"\n  }, {\n    \"name\": \"Understyle\",\n    \"href\": \"https://github.com/jxnblk/understyle\"\n  }]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"While React is extremely flexible in terms of how you can structure your application\\u2019s UI,\\nI\\u2019ve found that a few patterns for style composition have helped me keep things\\norganized and easy to work with.\\nThese aren\\u2019t hard-and-fast rules, these are simply reflections on how I\\u2019ve come to organize components in apps that I\\u2019ve worked on.\"), mdx(\"p\", null, \"I\\u2019ve gravitated towards these patterns in an effort to:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Create a well-defined visual design system\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Help maintain visual consistency across an application\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Only deliver the CSS/styles needed to the client for a given UI \\u2013 i.e. performance\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Increase the maintainability of visual styles\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Make updates and iterations on styles easier\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Make legacy styles easier to deprecate\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Create more readable components\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Make building out new UI easier and faster\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Keep styles encapsulated to help prevent collisions and unwanted side effects\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Create an easy-to-use component API for non-front-end developers\")), mdx(\"p\", null, \"Although the level of abstraction here might look like overkill for smaller projects,\\nI find that this general approach has sped up my development across the board.\"), mdx(\"p\", null, \"I won\\u2019t get into approaches for state management or handling the business logic of your app,\\ninstead I\\u2019ll be focusing primarily on the visible and interactive parts of the UI.\"), mdx(\"h2\", {\n    \"id\": \"stateless-functional-ui-components\"\n  }, \"Stateless Functional UI Components\"), mdx(\"p\", null, \"Generally, I like to keep styles separated from the parts of the app that are tied to state.\\nThat means routes, views, containers, forms, layouts, etc. should not have any styling or classes in them.\\nInstead, these heavy-lifting components should be composed of primarily stateless functional UI components,\\nsometimes referred to as \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"presentational\"), \" components.\\nBy keeping styling concerns separate from the application state,\\npieces can become more reusable and building out new views and containers can be quicker.\"), mdx(\"p\", null, \"For example, a form component render method might look something like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"render () {\\n  return (\\n    <form onSubmit={this.handleSubmit}>\\n      <Heading children='Sign In' />\\n      <Input\\n        name='username'\\n        value={username}\\n        onChange={this.handleChange} />\\n      <Input\\n        type='password'\\n        name='password'\\n        value={password}\\n        onChange={this.handleChange} />\\n      <Button\\n        type='submit'\\n        children='Sign In' />\\n    </form>\\n  )\\n}\\n\")), mdx(\"p\", null, \"Notice how none of the elements have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"className\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"style\"), \" prop.\\nUsing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"className\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"style\"), \" props at this level \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"could\"), \" be considered a code smell.\\nEach UI component used here encapsulates its own styling,\\nand the styling simply becomes an implementation detail,\\nwhich means a UI component can be updated or refactored without affecting anything else in the application.\"), mdx(\"p\", null, \"An example Button component, like the one in the form above, might look something like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const Button = ({\\n  ...props\\n}) => {\\n  const sx = {\\n    fontFamily: 'inherit',\\n    fontSize: 'inherit',\\n    fontWeight: 'bold',\\n    textDecoration: 'none',\\n    display: 'inline-block',\\n    margin: 0,\\n    paddingTop: 8,\\n    paddingBottom: 8,\\n    paddingLeft: 16,\\n    paddingRight: 16,\\n    border: 0,\\n    color: 'white',\\n    backgroundColor: 'blue',\\n    WebkitAppearance: 'none',\\n    MozAppearance: 'none'\\n  }\\n\\n  return (\\n    <button {...props} style={sx} />\\n  )\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Button usage\\n<Button onClick={this.handleClick}>\\n  Hello\\n</Button>\\n\")), mdx(\"p\", null, \"I\\u2019ve used inline styles here for readability and to help demonstrate how this works,\\nbut any CSS-in-JS solution can be used instead and won\\u2019t have any affect on the form component above.\\nBy keeping all styling encapsulated in this component,\\nthe rest of the application doesn\\u2019t need to know anything about the Button beyond its props API.\"), mdx(\"h2\", {\n    \"id\": \"styles-module\"\n  }, \"Styles Module\"), mdx(\"p\", null, \"You may have noticed that a few property values were hard-coded into the Button example.\\nGenerally, I wouldn\\u2019t recommend hard-coding things in like that.\\nAny values that are likely to be used across different UI components should be split into their own module.\"), mdx(\"p\", null, \"Here is an example module to start with:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"export const white = '#fff'\\nexport const black = '#111'\\nexport const blue = '#07c'\\n\\nexport const colors = {\\n  white,\\n  black,\\n  blue\\n}\\n\\nexport const space = [\\n  0,\\n  8,\\n  16,\\n  32,\\n  64\\n]\\n\\nconst styles = {\\n  bold: 600,\\n  space,\\n  colors\\n}\\n\\nexport default styles\\n\")), mdx(\"p\", null, \"And here is what the updated Button component could look like:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import React from 'react'\\nimport { bold, space, colors } from './styles'\\n\\nconst Button = ({\\n  ...props\\n}) => {\\n  const sx = {\\n    fontFamily: 'inherit',\\n    fontSize: 'inherit',\\n    fontWeight: bold,\\n    textDecoration: 'none',\\n    display: 'inline-block',\\n    margin: 0,\\n    paddingTop: space[1],\\n    paddingBottom: space[1],\\n    paddingLeft: space[2],\\n    paddingRight: space[2],\\n    border: 0,\\n    color: colors.white,\\n    backgroundColor: colors.blue,\\n    WebkitAppearance: 'none',\\n    MozAppearance: 'none'\\n  }\\n\\n  return (\\n    <button {...props} style={sx} />\\n  )\\n}\\n\")), mdx(\"p\", null, \"The style object could store anything related to styling that is shared across components,\\nincluding borders, border radii, shadows, animation duration, etc.\"), mdx(\"p\", null, \"You could even export more elaborate combinations of styles like the following:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"export const cardStyle = {\\n  backgroundColor: white,\\n  borderRadius: 3,\\n  boxShadow: `0 0 4px ${shade[1]}`\\n}\\n\")), mdx(\"p\", null, \"But I\\u2019d recommend delegating combinations like these to components and using composition instead, as I\\u2019ll show below.\"), mdx(\"h2\", {\n    \"id\": \"style-functions\"\n  }, \"Style Functions\"), mdx(\"p\", null, \"Since we\\u2019re using JavaScript, we can also employ helper functions for styling elements.\\nFor example, a function to create \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rgba\"), \" values of black can be very handy.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const darken = (n) => `rgba(0, 0, 0, ${n})`\\n\\ndarken(1 / 8) // 'rgba(0, 0, 0, 0.125)'\\n\")), mdx(\"p\", null, \"Functions like this can then be used to create a value scale array to help keep things consistent.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const shade = [\\n  darken(0),\\n  darken(1 / 8),\\n  darken(1 / 4),\\n  darken(3 / 8),\\n  darken(1 / 2),\\n  darken(5 / 8),\\n  darken(3 / 4),\\n  darken(7 / 8),\\n  darken(1)\\n]\\n\\nshade[4] // 'rgba(0, 0, 0, 0.5)'\\n\")), mdx(\"p\", null, \"Another example would be creating a scale for margin and padding to help keep visual rhythm consistent.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Modular powers of two scale\\nconst scale = [\\n  0,\\n  8,\\n  16,\\n  32,\\n  64\\n]\\n\\n// Functions to get partial style objects\\nconst createScaledPropertyGetter = (scale) => (prop) => (x) => {\\n  return (typeof x === 'number' && typeof scale[x] === 'number')\\n    ? { [prop]: scale[x] }\\n    : null\\n}\\nconst getScaledProperty = createScaledPropertyGetter(scale)\\n\\nexport const getMargin = getScaledProperty('margin')\\nexport const getPadding = getScaledProperty('padding')\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Style function usage\\nconst Box = ({\\n  m,\\n  p,\\n  ...props\\n}) => {\\n  const sx = {\\n    ...getMargin(m),\\n    ...getPadding(p)\\n  }\\n\\n  return <div {...props} style={sx} />\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Component usage\\n<div>\\n  <Box m={2} p={3}>\\n    A box with 16px margin and 32px padding\\n  </Box>\\n</div>\\n\")), mdx(\"h2\", {\n    \"id\": \"npm-modules\"\n  }, \"Npm Modules\"), mdx(\"p\", null, \"While the rgba color function above is a fairly simple one,\\nsometimes more complex color transformations can be helpful when creating UI.\\nWell, we\\u2019re in luck, because we can use literally anything on \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://npmjs.com\"\n  }), \"npm\"), \".\"), mdx(\"p\", null, \"Instead of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"darken\"), \" function above, here is an example using \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.npmjs.com/package/chroma-js\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"chroma-js\")), \"\\u2019s \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"alpha\"), \" function.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import chroma from 'chroma-js'\\n\\nconst alpha = (color) => (a) => chroma(color).alpha(a).css()\\n\\nconst darken = alpha('#000')\\n\\nconst shade = [\\n  darken(0),\\n  darken(1 / 8),\\n  darken(1 / 4),\\n  // ...\\n]\\n\")), mdx(\"p\", null, \"Using chroma, this function can work with any color from the style object.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const blueAlpha = [\\n  alpha(blue)(0),\\n  alpha(blue)(1 / 4),\\n  alpha(blue)(1 / 2),\\n  alpha(blue)(3 / 4),\\n  alpha(blue)(1)\\n]\\n\")), mdx(\"h2\", {\n    \"id\": \"base-component\"\n  }, \"Base Component\"), mdx(\"p\", null, \"Beyond just importing style values, there is a tremendous amount of flexibility\\nwhen it comes to composition in React \\u2013 since components are essentially just functions.\\nTake the Button component from above, and we\\u2019ll change some of the style details to props to make it more reusable.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const Button = ({\\n  big,\\n  color = colors.white,\\n  backgroundColor = colors.blue,\\n  ...props\\n}) => {\\n  const sx = {\\n    fontFamily: 'inherit',\\n    fontSize: 'inherit',\\n    fontWeight: bold,\\n    textDecoration: 'none',\\n    display: 'inline-block',\\n    margin: 0,\\n    paddingTop: big ? space[2] : space[1],\\n    paddingBottom: big ? space[2] : space[1],\\n    paddingLeft: space[2],\\n    paddingRight: space[2],\\n    border: 0,\\n    color,\\n    backgroundColor,\\n    WebkitAppearance: 'none',\\n    MozAppearance: 'none'\\n  }\\n\\n  return (\\n    <button {...props} style={sx} />\\n  )\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Usage example\\n<div>\\n  <Button>\\n    Blue Button\\n  </Button>\\n  <Button big backgroundColor={colors.red}>\\n    Big Red Button\\n  </Button>\\n</div>\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"color\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"backgroundColor\"), \" properties have been moved up to the component\\u2019s props.\\nAdditionally, we\\u2019ve added a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"big\"), \" prop to adjust the padding top and bottom.\"), mdx(\"p\", null, \"Now this component is fine by itself, but what if we want a secondary button style?\\nDoing the following would become tedious and error prone very quickly:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"<Button\\n  color={colors.black}\\n  backgroundColor={colors.lightblue}\\n  children='Secondary Button' />\\n\")), mdx(\"p\", null, \"Instead, we can create a dedicated secondary button component.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import React from 'react'\\nimport Button from './Button'\\n\\nconst ButtonSecondary = (props) => (\\n  <Button\\n    {...props}\\n    color={colors.black}\\n    backgroundColor={colors.lightblue} />\\n)\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Usage example\\n<div>\\n  <Button>Normal Button</Button>\\n  <ButtonSecondary>Secondary Button</ButtonSecondary>\\n</div>\\n\")), mdx(\"p\", null, \"By adjusting the props API of the base Button component, an entire set of button styles can be created.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const ButtonBig = (props) => <Button {...props} big />\\nconst ButtonGreen = (props) => <Button {...props} backgroundColor={colors.green} />\\nconst ButtonRed = (props) => <Button {...props} backgroundColor={colors.red} />\\nconst ButtonOutline = (props) => <Button {...props} outline />\\n\")), mdx(\"p\", null, \"This pattern lends itself well to layout components as well.\\nAssume we have a generic Box component that accepts props for various layout styles.\\nThis base layout component can then be used to create grid system components and other primitives.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const Grid = (props) => (\\n  <Box {...props}\\n    display='inline-block'\\n    verticalAlign='top'\\n    px={2} />\\n)\\n\\nconst Half = (props) => (\\n  <Grid {...props}\\n    width={1 / 2} />\\n)\\n\\nconst Third = (props) => (\\n  <Grid {...props}\\n    width={1 / 3} />\\n)\\n\\nconst Quarter = (props) => (\\n  <Grid {...props}\\n    width={1 / 4} />\\n)\\n\\nconst Flex = (props) => (\\n  <Box {...props}\\n    display='flex' />\\n)\\n\\nconst FlexAuto = (props) => (\\n  <Box {...props}\\n    flex='1 1 auto' />\\n)\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Usage example\\n<div>\\n  <div>\\n    <Half>Half width column</Half>\\n    <Half>Half width column</Half>\\n  </div>\\n  <div>\\n    <Third>Third width column</Third>\\n    <Third>Third width column</Third>\\n    <Third>Third width column</Third>\\n  </div>\\n  <div>\\n    <Quarter>Quarter width column</Quarter>\\n    <Quarter>Quarter width column</Quarter>\\n    <Quarter>Quarter width column</Quarter>\\n    <Quarter>Quarter width column</Quarter>\\n  </div>\\n</div>\\n\")), mdx(\"p\", null, \"Typography styles are another great candidate for building up with composition.\\nBy using a base typographic component, you can help ensure consistency and keep your styling DRY.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import React from 'react'\\nimport { alternateFont, typeScale, boldFontWeight } from './styles'\\n\\nconst Text = ({\\n  tag = 'span',\\n  size = 4,\\n  alt,\\n  center,\\n  bold,\\n  caps,\\n  ...props\\n}) => {\\n  const Tag = tag\\n  const sx = {\\n    fontFamily: alt ? alternateFont : null,\\n    fontSize: typeScale[size],\\n    fontWeight: bold ? boldFontWeight : null,\\n    textAlign: center ? 'center' : null,\\n    textTransform: caps ? 'uppercase' : null\\n  }\\n\\n  return <Tag {...props} style={sx} />\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const LeadText = (props) => <Text {...props} tag='p' size={3} />\\nconst Caps = (props) => <Text {...props} caps />\\nconst MetaText = (props) => <Text {...props} size={5} caps />\\nconst AltParagraph = (props) => <Text {...props} tag='p' alt />\\n\\nconst CapsButton = ({ children, ...props }) => (\\n  <Button {...props}>\\n    <Caps>\\n      {children}\\n    </Caps>\\n  </Button>\\n)\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Usage example\\n<div>\\n  <LeadText>\\n    This is a lead with some <Caps>all caps</Caps>.\\n    It has a larger font size than the default paragraph.\\n  </LeadText>\\n  <MetaText>\\n    This is smaller text, like form helper copy.\\n  </MetaText>\\n</div>\\n\")), mdx(\"p\", null, \"Keep in mind, that these components are just a few examples and your needs will vary greatly on an app-by-app basis.\"), mdx(\"h2\", {\n    \"id\": \"higher-order-components\"\n  }, \"Higher Order Components\"), mdx(\"p\", null, \"I\\u2019m generally a fan of keeping most of an applications state at the top level of a React tree,\\noften using something like \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/reactjs/redux\"\n  }), \"Redux\"), \".\\nHowever, sometimes there are isolated UI components that only require a minimal amount of state for interaction,\\nand using them as standalone components is sufficient.\"), mdx(\"p\", null, \"One example of this is a carousel\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"#*\"\n  }), \"*\"), \", where the state of the current slide generally doesn\\u2019t need to persist across page views.\\nInstead of combining the state of the carousel with its UI, we can create a higher order component for better reusability.\\nThe higher order component will have a current slide index and have previous and next methods.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Higher order component\\nimport React from 'react'\\n\\n// This could be named something more generic like Counter or Cycle\\nconst CarouselContainer = (Comp) => {\\n  class Carousel extends React.Component {\\n    constructor () {\\n      super()\\n      this.state = {\\n        index: 0\\n      }\\n      this.previous = () => {\\n        const { index } = this.state\\n        if (index > 0) {\\n          this.setState({ index: index - 1})\\n        }\\n      }\\n\\n      this.next = () => {\\n        const { index } = this.state\\n        this.setState({ index: index + 1 })\\n      }\\n    }\\n\\n    render () {\\n      return (\\n        <Comp\\n          {...this.props}\\n          {...this.state}\\n          previous={this.previous}\\n          next={this.next} />\\n      )\\n    }\\n  }\\n\\n  return Carousel\\n}\\n\\nexport default CarouselContainer\\n\")), mdx(\"p\", null, \"Using a higher order component we can create a carousel from any number of UI elements.\\nFor example, a simple carousel may have only previous and next buttons,\\nwhile a more complex one might include image thumbnails of each slide across the bottom.\\nBoth of these can use the same higher order component to handle their state.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// UI component\\nconst Carousel = ({ index, ...props }) => {\\n  const length = props.length || props.children.length || 0\\n\\n  const sx = {\\n    root: {\\n      overflow: 'hidden'\\n    },\\n    inner: {\\n      whiteSpace: 'nowrap',\\n      height: '100%',\\n      transition: 'transform .2s ease-out',\\n      transform: `translateX(${index % length * -100}%)`\\n    },\\n    child: {\\n      display: 'inline-block',\\n      verticalAlign: 'middle',\\n      whiteSpace: 'normal',\\n      outline: '1px solid red',\\n      width: '100%',\\n      height: '100%'\\n    }\\n  }\\n\\n  const children = React.Children.map(props.children, (child, i) => {\\n    return (\\n      <div style={sx.child}>\\n        {child}\\n      </div>\\n    )\\n  })\\n\\n  return (\\n    <div style={sx.root}>\\n      <div style={sx.inner}>\\n        {children}\\n      </div>\\n    </div>\\n  )\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Final Carousel component\\nconst HeroCarousel = (props) => {\\n    return (\\n    <div>\\n      <Carousel index={props.index}>\\n        <div>Slide one</div>\\n        <div>Slide two</div>\\n        <div>Slide three</div>\\n      </Carousel>\\n      <Button\\n        onClick={props.previous}\\n        children='Previous' />\\n      <Button\\n        onClick={props.next}\\n        children='Next' />\\n    </div>\\n    )\\n}\\n\\n// Wrap the component with the functionality from the higher order component\\nexport default CarouselContainer(HeroCarousel)\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// Usage example\\n<div>\\n  <HeroCarousel />\\n</div>\\n\")), mdx(\"p\", null, \"By keeping the styling separate from the interactive state,\\nany number of carousel variations can be created from these reusable parts.\"), mdx(\"p\", null, \"Just like the base component pattern above, higher order components\\ncan work well for styling layout, typography and colors.\\nThis is the same pattern used in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/jxnblk/reflexbox\"\n  }), \"Reflexbox\"), \",\\nand similar to Rebass\\u2019s \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/jxnblk/rebass/blob/master/src/Base.js\"\n  }), \"Base component\"), \".\"), mdx(\"h2\", {\n    \"id\": \"further-exploration\"\n  }, \"Further Exploration\"), mdx(\"p\", null, \"These are just a few patterns that I\\u2019ve found to be the most useful\\nwhen it comes to styling UI in a component-based system.\\nI\\u2019m curious to know if anyone else has found similar patterns that they\\u2019ve found helpful,\\nand I\\u2019m sure there are even more ways to create more beautiful, more flexible, and more maintainable visual design systems.\"), mdx(\"hr\", null), mdx(\"h3\", {\n    \"id\": \"a-note-about-performance\"\n  }, \"A Note About Performance\"), mdx(\"p\", null, \"While there are many different ways to handle styling in a component-based app,\\nmake sure to pay close attention to the size of your bundle.\\nIt can be easy to create the wrong abstractions and end up with needless bloat.\\nSome of the patterns in this article, when taken to their logical extreme,\\ncould actually harm the performance and create a degraded experience for your end users.\"), mdx(\"p\", null, \"And remember, everything related to styling that you do should be for the user\\u2019s benefit, not your own.\"), mdx(\"hr\", null), mdx(\"small\", {\n    id: \"*\"\n  }, \"* Please don\\u2019t use carousels in your app. Users hate them.\"));\n}\nMDXContent.isMDXComponent = true;"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"f5d2ef85-f8a1-5490-8d9b-b1ab9c6b5674"}}}